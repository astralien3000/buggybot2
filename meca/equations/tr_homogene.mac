/* Elementary homogeneous transformations matrices  */
rot_x(th):=matrix(
  [1, 0     ,0       ,0],
  [0,cos(th),-sin(th),0],
  [0,sin(th), cos(th),0],
  [0, 0     , 0      ,1])$

rot_y(th):=matrix(
  [ cos(th),0,sin(th),0],
  [ 0      ,1,0      ,0],
  [-sin(th),0,cos(th),0],
  [0, 0     , 0      ,1])$

rot_z(th):=matrix(
  [cos(th),-sin(th),0,0],
  [sin(th), cos(th),0,0],
  [0      , 0      ,1,0],
  [0      , 0      ,0,1])$

trans(x,y,z):=matrix(
  [1,0,0,x],
  [0,1,0,y],
  [0,0,1,z],
  [0,0,0,1])$

/* Other transformation matrix */
/* WARNING ! Can't be inverted by following methods */
scal(x,y,z):=matrix(
  [x,0,0,0],
  [0,y,0,0],
  [0,0,z,0],
  [0,0,0,1])$  

/* invert homegeneous transformation matrix  */
inv_SO3_h(loc_iTj):=block(
  [ jRi , jOi, jTi ],
  jRi:transpose(submatrix(4,loc_iTj,4)),
  jOi:-jRi.submatrix(4,loc_iTj,1,2,3),
  jTi:addcol(jRi,jOi),
  jTi:addrow(jTi,[0,0,0,1])
);

/* TODO : would be a good thing to have the rotation around any axis , using rodrigues formula... */

/* direct computation of cross-product between two vectors a and b : a ^ b = a x b  */
cross_prod(loc_a,loc_b):=matrix(
   [loc_a[2,1]*loc_b[3,1]-loc_a[3,1]*loc_b[2,1]],
   [loc_a[3,1]*loc_b[1,1]-loc_a[1,1]*loc_b[3,1]],
   [loc_a[1,1]*loc_b[2,1]-loc_a[2,1]*loc_b[1,1]]
)$

/* skew anti-symetric matrix associated to left cross-product by a : a ^ b = a x b = S(a) .b */
get_s(loc_a):=matrix(
  [ 0          ,-loc_a[3,1], loc_a[2,1] ],
  [ loc_a[3,1] , 0         ,-loc_a[1,1] ],
  [-loc_a[2,1] , loc_a[1,1], 0      ]
)$

get_w(loc_S):=matrix([loc_S[3,2]],[loc_S[1,3]],[loc_S[2,1]])$

/* point and vector frame coordinates conversion */
apply_point(loc_iTj,loc_Pj):=submatrix(4,loc_iTj).addrow(loc_Pj,[1])$
apply_vec(loc_iTj,loc_Vj):=submatrix(4,loc_iTj).addrow(loc_Vj,[0])$
